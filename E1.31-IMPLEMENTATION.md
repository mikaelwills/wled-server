# E1.31 (sACN) Implementation for WLED Control

## Overview

This document describes the E1.31 (Streaming ACN) implementation used for controlling WLED boards via UDP unicast. E1.31 was implemented to solve WebSocket buffer overflow issues during music-synchronized light sequences.

## Why E1.31 Instead of WebSocket?

**Problem:** WebSocket connections buffer commands and can overflow during rapid music-synchronized sequences, causing boards to become unresponsive.

**Solution:** E1.31 uses UDP, which is connectionless and doesn't buffer. Packets are sent and forgotten (fire-and-forget), preventing buffer overflow issues.

## Implementation Details

### Raw E1.31 Implementation

We use a **custom raw E1.31 implementation** (`src/transport/e131_raw.rs`) instead of the `sacn` Rust library because the sacn library was found to be **incompatible with WLED**. The sacn library's packets were not recognized by WLED boards.

The raw implementation manually constructs E1.31 packets following the sACN specification:
- Root Layer (38 bytes)
- Framing Layer (77 bytes + universe)
- DMP Layer (11 bytes + DMX data)
- DMX Data (512 bytes)

### WLED E1.31 Mode 10 (Preset Mode)

WLED's E1.31 mode 10 is called "Preset Mode" and uses **2 DMX channels** (not 1 as initially documented):

- **Channel 0 (dmx_data[0])**: Master brightness (0-255)
  - 0 = lights off (blackout)
  - 1-255 = brightness level
- **Channel 1 (dmx_data[1])**: Preset ID (1-250)
  - Triggers the specified preset on the board

### Configuration

Boards must be configured via WLED's `/json/cfg` API endpoint:

```json
{
  "if": {
    "live": {
      "en": true,           // Enable live data
      "mc": false,          // Multicast disabled (use unicast)
      "dmx": {
        "uni": 1,           // Universe 1
        "mode": 10          // Preset mode
      }
    }
  }
}
```

### Unicast vs Multicast

**We use unicast** instead of multicast because:
1. Multicast packets were not reaching WLED boards (network routing issues)
2. Unicast allows targeting specific boards
3. Unicast works reliably on all network configurations

**Unicast implementation:**
- Sends individual UDP packets to each board IP on port 5568
- Uses `UdpSocket::send_to()` with specific board addresses
- Returns success if at least one board receives the packet (partial success)

### Group Commands

Group commands send a **single E1.31 packet to each board** in the group (not one multicast packet to all). This ensures:
- All boards receive the command
- Offline boards don't cause failures
- Partial success when some boards are unreachable

Group configuration (in `src/main.rs`):
```rust
let group_board_ips = vec![
    "192.168.8.148".to_string(),  // Board One
    "192.168.8.118".to_string(),  // Board Two
    "192.168.8.210".to_string(),  // Board Three
];
let group_e131 = transport::E131RawTransport::new(group_board_ips, 1)?;
```

### Command Types

#### 1. Set Preset
```rust
dmx_data[0] = 0;       // Brightness (0 = use preset's own brightness)
dmx_data[1] = preset;  // Preset ID (1-250)
```

#### 2. Power On
```rust
dmx_data[0] = 255;     // Full brightness
dmx_data[1] = preset;  // Preset ID to activate
```

#### 3. Power Off
```rust
dmx_data[0] = 0;       // Brightness = 0 (blackout)
dmx_data[1] = preset;  // Keep current preset (unused)
```

#### 4. Set Brightness
```rust
dmx_data[0] = brightness;  // Master brightness (0-255)
dmx_data[1] = preset;      // Current preset ID
```

## Transition Times

**Important:** E1.31 preset changes are **always instant** (tt:0) because:

1. WLED's `applyPreset()` is called with `CALL_MODE_NOTIFICATION` when triggered via E1.31
2. WLED does **not store** transition times in presets - transition is a runtime parameter
3. This is correct for music synchronization where instant changes are required

The `transition` field in our `presets/presets.json` is used when **syncing presets to boards via HTTP API**, but E1.31 mode 10 always applies presets instantly.

## Packet Format

### E1.31 Packet Structure
```
┌─────────────────────────────────────┐
│ Root Layer (38 bytes)               │
│  - Preamble Size: 0x0010            │
│  - ACN Packet ID: "ASC-E1.17"       │
│  - Vector: VECTOR_ROOT_E131_DATA    │
│  - CID: 16-byte UUID                │
├─────────────────────────────────────┤
│ Framing Layer (77 bytes)            │
│  - Vector: VECTOR_E131_DATA_PACKET  │
│  - Source Name: "WLED Rust Server"  │
│  - Priority: 100                    │
│  - Universe: 1                      │
├─────────────────────────────────────┤
│ DMP Layer (11 bytes)                │
│  - Vector: VECTOR_DMP_SET_PROPERTY  │
│  - Address Type: 0xa1               │
│  - DMX Start Code: 0x00             │
├─────────────────────────────────────┤
│ DMX Data (512 bytes)                │
│  - dmx_data[0]: Brightness          │
│  - dmx_data[1]: Preset ID           │
│  - dmx_data[2-511]: Unused (0x00)   │
└─────────────────────────────────────┘
Total packet size: 638 bytes
```

## Error Handling

### Partial Success
E1.31 commands succeed if **at least one board** receives the packet:
```rust
if success_count > 0 {
    info!("E1.31 unicast completed ({}/{} boards)", success_count, total);
    Ok(())
} else {
    Err("Failed to send to any boards")
}
```

### Offline Boards
Offline boards log errors but don't fail the operation:
```
ERROR Failed to send raw E1.31 packet board_ip=192.168.8.148:5568 error=Host is down
INFO  Sent raw E1.31 packet board_ip=192.168.8.118:5568
INFO  Sent raw E1.31 packet board_ip=192.168.8.210:5568
INFO  E1.31 unicast completed (2/3 boards)
```

## Performance

### Advantages over WebSocket
1. **No buffer overflow** - UDP is connectionless, no queuing
2. **Lower latency** - Fire-and-forget, no acknowledgments
3. **Simpler state management** - No connection tracking per board
4. **Network efficiency** - Single UDP packet per command

### Packet Overhead
- **Packet size:** 638 bytes
- **Frequency:** On-demand (triggered by cue markers in music sequences)
- **Typical usage:** 10-50 packets per minute during active sequences

## Testing Results

**Success metrics from production use:**
- ✅ 5 consecutive program sequences with zero failures
- ✅ 2/3 boards responding (one offline, handled gracefully)
- ✅ Instant preset changes (tt:0)
- ✅ No WebSocket fallback needed
- ✅ No buffer overflow or unresponsiveness issues

## Files

- `src/transport/e131_raw.rs` - Raw E1.31 packet implementation
- `src/transport/e131.rs` - Legacy sacn library wrapper (not used)
- `src/group.rs` - Group command execution via E1.31
- `src/main.rs` - E1.31 transport initialization

## Future Improvements

1. **Remove sacn dependency** - No longer needed, can be removed from Cargo.toml
2. **Dynamic group configuration** - Currently hardcoded in main.rs
3. **Per-board E1.31 support** - Currently only groups use E1.31
4. **Sequence number tracking** - Currently wraps at 255, could add validation
5. **Priority configuration** - Currently fixed at 100, could be configurable

## References

- [E1.31 Specification (sACN)](https://tsp.esta.org/tsp/documents/docs/ANSI_E1-31-2018.pdf)
- [WLED E1.31 Implementation](https://github.com/Aircoookie/WLED/blob/main/wled00/e131.cpp)
- [WLED DMX Modes](https://github.com/Aircoookie/WLED/blob/main/wled00/const.h)
